# AutoFuzz

[![](https://img.shields.io/badge/Python-3.8+-blue.svg)](https://www.python.org/downloads/)

Automatic Fuzzer-Sanitizer Scheduling with Multi-Armed Bandit

## Publication

> [Gao, Y., Zeng, W., Liu, S., & Zeng, Y. (2025). AutoFuzz: automatic fuzzer-sanitizer scheduling with multi-armed bandit. Software Quality Journal, 33(1), 8.](https://link.springer.com/article/10.1007/s11219-025-09707-6)

## What this project does

This project is dedicated to using reinforcement learning algorithms to schedule between many different fuzzers.

As you may know, different fuzzers are good at testing different types of vulnerabilities. But it's hard to know which fuzzer is more suitable for the program until the test starts. This project uses reinforcement learning algorithms to try to run different fuzzers and determine their execution efficiency by the number of new crashes they find, new code coverage they made, and other parameters, and then select the most suitable one for deeper testing.

## How to use

This module provides a launcher function.

After importing the module, the scheduler can be started using the `run_it()` function.

As long as the same `progress_recovery_path` parameter is used and you exited normally last time, you can continue fuzzing with the previous progress.

It is safe to press `<Ctrl+C>` at any time. Please be patient as it may take some time to exit due to some cleanup work that needs to be done. Forced exit may result in not being able to continue this fuzzing next time.

Before use, you need to install the required packages. You can do this by running the following command:

```bash
python3 -m pip install -U SMPyBandits psutil prometheus-client
```

### Function prototype

autofuzz.**run_it**(*[methods_info](#methods_info)*, *[crash_analysis_command](#crash_analysis_command)*, *[covelf_command](#covelf_command)*, *[seed_path=None](#seed_path)*, *[startup_time=120](#startup_time)*, *[runner_type=None](#runner_type)*, *[method_additional_env=None](#method_additional_env)*, *[crash_analysis_command_additional_env=None](#crash_analysis_command_additional_env)*, *[llvmprofdata_command="llvm-profdata"](#llvmprofdata_command--llvmcov_command)*, *[llvmcov_command="llvm-cov"](#llvmprofdata_command--llvmcov_command)*, *[runner_thread=3](#runner_thread)*, *[analysis_thread=0](#analysis_thread)*, *[cycle_time=450](#cycle_time)*, *[running_status_csv_path="data.csv"](#running_status_csv_path)*, *[crashes_output_json_path=None](#crashes_output_json_path)*, *[crashes_output_path="crashes"](#crashes_output_path)*, *[progress_recovery_path="output"](#progress_recovery_path)*, *[support_SIGUSR2_sync=False](#support_sigusr2_sync--support_sigusr2_stats)*, *[support_SIGUSR2_stats=False](#support_sigusr2_sync--support_sigusr2_stats)*, *[run_round=0](#run_round)*, *[reference_time=86400](#reference_time)*, *[cpu_list=None](#cpu_list)*, *[round_robin=False](#round_robin)*, *[prometheus_port=None](#prometheus_port)*)

### Parameters

#### `methods_info`

  A *list* containing several *dict*s, each representing information about a fuzzy test instance.

  - `name`

    A *str* value represents the name of this fuzzy test instance.

  - `shell_command`

    A *str* value represents the command to run this fuzzy test instance.

    The following placeholders can be used. These placeholders will be filled at runtime with the context-specific values generated by the corresponding parameters.

    - `#n`: Identifiers, constructed from `name` mentioned above.
    - `#i`: Initial seed path, constructed from [`seed_path`](#seed_path).
    - `#o`: Progress recovery path, constructed from [`progress_recovery_path`](#progress_recovery_path).
    - `#b`: Specific CPU index, constructed from [`cpu_list`](#cpu_list).
    - `#c`: Crash output path. Only be used in LibFuzzer-Style fuzzers.
    - `##`: `#` itself.

    Please note that placeholders will not be replaced in the following cases, which may have an impact on the program being tested.

    1. If the corresponding parameter is not given or is not usable (e.g. `#b`).

    2. Starting with `##`. which is useful when you need to use this string in the command and don't want it to be replaced automatically.

    3. If the placeholder does not exist. That is, a non-placeholder starting with `#` will not be replaced.

  - [`runner_type`](#runner_type),

    [`seed_path`](#seed_path),

    [`startup_time`](#startup_time),

    [`method_additional_env`](#method_additional_env),

    [`support_SIGUSR2`](#support_SIGUSR2)

    Neither is required.

    If specified, a different setting is specified for the instance than the global parameter. If not specified, the global one is used. Note that the corresponding variables will be REPLACED, not appended.

    See the corresponding global parameter for the exact meaning.

<details>
<summary><h4>Special use: Continuous mode</h4></summary>

  If only one instance is provided in `methods_info`, the continuous mode will be activated.

  In continuous mode, the "virtual rounds" will be triggered according to `cycle_time`. At the end of each virtual round, the data will be counted in the analysis thread, while the main thread will continue to fuzz.

  Note that in this mode, there is no directory corresponding to RunnerPool in `progress_recovery_path`, but directly the Runner's directory, and no seed distribution will be made.

  This mode is mainly used to record data at runtime for comparative testing. There is nearly no performance loss in this mode compared to running fuzzer directly. Data analysis may continue for a period of time after the scheduled time, but this does not affect the data validity of the comparison test.

</details>

#### `seed_path`

  A *str* value represents the path to the initial seed.

  Note that if you use this parameter, use the `#i` placeholder in `shell_command` inside `methods_info`. We will automatically replace this placeholder with the appropriate path.

  Depends on the type of fuzzer, it's not always necessary to provide this parameter. As for AFL-Style fuzzer, it's safe to direct set initial seed path by it's `-i` parameter in `shell_command`. While for LibFuzzer-Style fuzzer, it's necessary to provide this parameter, since we need to make a copy of initial seed for each runner.

#### `startup_time`

  An *int* value represents the **max** time it will wait for the instance to start.

  Setting this value to 0 allows infinite waiting. This is useful when you are sure the instance will start properly but don't know how long it will take, and please note that this is dangerous on time-billed devices.

  Loading more initial seeds takes longer to start. If this time is shorter than the time needed to start, it may cause the instance to fail to start or cause some other unexpected consequences.

#### `runner_type`

  A subclass object of `autofuzz.base_runner.BaseRunner`. This parameter specifies the type of the runner.

  Different types of runner will use different ways of reading data, so be sure to select the correct one.

  All available fuzzer types can be found [here](autofuzz/runner).

  If you want to adapt to other types of fuzzer, see [this article](/autofuzz/runner/README.md#how-to-adapt-to-other-types-of-fuzzer).

#### `method_additional_env`

  A *dict* value represents additional environment variables required by the instance.

  These environment variables will be added when the instance is started.

#### `crash_analysis_command`

  A *dict* where the key is `ASAN`, `MSAN`, `TSAN` or `UBSAN` and the value accepts a *string* or *tuple*.

  - When using a *string*

    Representing the command to be run during crash analysis.

    We support using the `@@` tag in the command to automatically replace the filename at runtime.

  - When using a *tuple*

    - The first item is the same as above.

    - The second item is a *dict* used to override the setting of environment variables by the global parameter `crash_analysis_command_additional_env`. See below for details.

  If you wish to use another crash analysis method, see [the paragraph below](#i-want-to-add-new-crash-analysis-methods).

#### `crash_analysis_command_additional_env`

  A *dict* value represents additional environment variables required by the crash analysis instance.

  These environment variables will be added when the crash analysis instance is started.

  **Warning**: We have set the following environment variables internally. Please do not specify these environment variables here unless you really need to override them. The settings here take HIGHER priority than the internal defaults!

  - `ASAN_OPTIONS`
  - `MSAN_OPTIONS`
  - `UBSAN_OPTIONS`

#### `covelf_command`

  Accepts a *string* or *tuple*.

  Normally, a *tuple* needs to be passed:

  - The first item is a *string*, representing the command to run coverage analysis.

    We support using the `@@` tag in the command to automatically replace the filename at runtime.

  - The second item is a *dict* used to set additional environment variables required by coverage analysis.

    These environment variables will be added when coverage analysis is started.

  - The third item is a *string*, representing the path of the coverage analysis elf.

    The difference between this item and the first one is that the first one represents the full command at runtime and may contain other commands, command parameters, etc., while this item only represents the path to elf itself for running coverage analysis.

  The second item and the third item are optional (Yes, you can provide the third item but not the second). A empty dictionary would be used when the second item is missing, and the first command part of the first argument would be used when the third item is missing.

  When neither the second item nor the third item is offered, there is no need to provide *tuple*, simply provide *string*.

#### `llvmprofdata_command` & `llvmcov_command`

  Accepts a *string* or *tuple*.

  - When using a *string*

    Representing the command to run `llvm-profdata` & `llvm-cov`.

  - When using a *tuple*

    - The first object is the same as above.

    - The second object is a *dict* used to set additional environment variables required by `llvm-profdata` & `llvm-cov`. These environment variables will be added when `llvm-profdata` & `llvm-cov` is started.

#### `runner_thread`

  An *int* value represents the number of concurrent instances per different fuzzer.

#### `analysis_thread`

  An *int* value represents the number of concurrent instances for analyze.

  If the number is less than or equal to 0, it will be set to be equal to `runner_thread`.

  Tip:

  Setting this value large helps to reduce the analysis time and can increase the effective runtime percentage. Setting this value low will reduce the additional CPU usage.

  The CPU cores used for analysis are bursty, so if you are running multiple instances of AutoFuzz at the same time and they run a few minutes apart, the cores used for analysis can be treated as shared.

  The sweet spot for this value is set equal to runner_thread, which has a more balanced performance most of the time. It is not recommended to change this value manually unless there is a specific reason to do so.

#### `cycle_time`

  An *int* value represents the time of each round of fuzzing.

  This time should not be too short, otherwise, there will be many rounds without any data output.

#### `running_status_csv_path`

  A *str* value represents where to output your running performance logs.

#### `crashes_output_json_path`

  A *str* value represents where to output your crash report.

  If left empty, it is automatically saved in `crashes_output_path`, named `summary.json`

#### `crashes_output_path`

  A *str* value represents where to save the crashes found.

#### `progress_recovery_path`

  A *str* value represents the path where the temporary files for progress recovery are saved.

  Note that if you use this parameter, use the `#o` placeholder in `shell_command` inside `methods_info`. We will automatically replace this placeholder with the appropriate path.

#### `support_SIGUSR2_sync` & `support_SIGUSR2_stats`

  A *bool* value represents whether your fuzzer support `SIGUSR2` signal for inter-fuzzer sync & write stats files.

  For more information, see [the paragraph below](#what-does-support_sigusr2-means).

#### `run_round`

  An *int* value represents the number of rounds to run the scheduling.

  If the number is less than or equal to 0, it will keep running until `<Ctrl+C>` is pressed.

  Note that the initialization does not count the number of rounds.

  It is highly recommended to set this parameter, or the [`reference_time`](#reference_time) mentioned below, as they will be involved in scheduling decisions. When both are specified it will be calculated using this parameter. If neither is specified, decisions will be made based on the default value of [`reference_time`](#reference_time), which may lead to performance degradation. (Unless you are using [Continuous Mode](#special-use-continuous-mode), which does not affect reliability without setting this parameter.)

#### `reference_time`

  An *int* value representing the expected running time.

  The actual running time is determined by `cycle_time` and `run_round` (and of course, the time when you press `<Ctrl+C>`). This parameter is only used to provide a reference for scheduling when `run_round` is less than or equal to 0 (in which case it will run infinitely).

#### `cpu_list`

  A *list* object contains several *int* values representing the list of cpu's that will be used.

  This is an optional parameter. Keep it as `None` to not specify the CPU.

  Note that if you use this parameter, use the `#b` placeholder in `shell_command` inside `methods_info`, `crash_analysis_command` or `covelf_command`. We will automatically replace this placeholder with the appropriate CPU index.

  Warning: Make sure that the number of CPUs provided is greater than or equal to `runner_thread + analysis_thread`, otherwise this parameter will not take effect. In this case the `#b` placeholder will not be replaced, then an error may be raised.

#### `round_robin`

  A *bool* value represents whether to use *Round-Robin mode*.

  In Round-Robin mode, each available fuzzer will be scheduled cyclically, and the analysis results of each round will not involve in the scheduling. This is just a simple scheduling mode for comparison testing.

#### `prometheus_port`

  An *int* value represents the port of Prometheus exporter.

  If left empty, Prometheus exporter will be disabled.

### What does `support_SIGUSR2` means?

Fuzzers will collect progress data from other fuzzer instances periodically when it runs, but this is unpredictable. We want the instance to collect data from other instances as soon as it resumes running to improve performance, so we modified some fuzzer code to use the `SIGUSR2` signal for fuzzer instance to collect immediately.

Also, fuzzer updates the stats file periodically, which is also unpredictable. So we modified some code to update the stats file as soon as `SIGUSR2` is sent.

The modified code can be viewed in the table below. If your fuzzer uses our modified code or has modified the code yourself to allow the features above via `SIGUSR2`, you can set this parameter to `True` to improve performance, otherwise, set it to False.

|        Fuzzer        | Version |                  Repo                   | Support SIGUSR2<br>(For Seed Sync) | Support SIGUSR2<br>(For Update Stats File) | Core Binding Option |
| :------------------: | :-----: | :-------------------------------------: | :--------------------------------: | :----------------------------------------: | :-----------------: |
|         AFL          | v2.57b  |     https://github.com/AutoFuzz/AFL     |                 ✓                  |                     ✓                      |         -b          |
|        AFL++         | c7bb0a9 | https://github.com/AutoFuzz/AFLplusplus |                 ✓                  |                     ✓                      |         -b          |
|         MOpt         | a9a5dc5 |  https://github.com/AutoFuzz/MOpt-AFL   |                 ✓                  |                     ✓                      |         -c          |
| FairFuzz<br>(afl-rb) | e529c1f |   https://github.com/AutoFuzz/afl-rb    |                 ✓                  |                     ✓                      |         -c          |

## I want to add new crash analysis methods

To use the new crash analyzer, you need to accomplish a few things.

### Write your parse function

In the header of the `autofuzz/crash_analysis.py` file, you will see several built-in parse functions, you will need to write your parse function after them.

The first argument of the parse function must be `stderr`, a *string* which will be passed automatically by the caller. All you need to do is parse `stderr` to get a tuple of the form `(vulntype, funcname, stack_hashes)`. The first two objects are strings and the third object is a sequence object containing several strings. The first string is the vulnerability type, the second is user-friendly crash location information, and the third is the hashes of the crash. We use the hash to confirm if the crash is a duplicate, so please consider the hash calculation carefully to avoid over-reporting or missing crashes.

The order of the sequence represents the level at which this hash was generated. A lower level represents a higher duplication rate. If the first few hashes in the sequence are found to have no duplicates, but duplicates are found in the later parts of the sequence, this will be considered as a low duplicate of the former crash, and will be given some weight. If a duplicate is found in the first place, it is considered to be almost the same as the previous one and is given little extra weight.

Since some crash parsers support reporting multiple crashes, we agree that the return value of the parse function MUST be an iterable object with each element in it being a tuple as shown above, even if your parse can only return one crash at a time. Therefore, it may be necessary to write it using something like `return ((vulntype, funcname, stack_hashes), )`.

The parse function can have more than one parameter, see the next part for details.

**IMPORTANT NOTE**

Because the crash type is not known when stderr is distributed, there is a high probability that your parser will get an unparseable text. If it is not what you can parse, return `(("", "", []), )`. This special return value will tell the caller to parse using the next parser.

### Modify `ORDER`

`ORDER` is a list that contains all the available parser functions in order. You need to insert your parser functions in the appropriate places.

Each item of `ORDER` is a `_order_struct` object. The elements it has are as follows.

- The first element (`type env parse_func args`)

  A *str* value represents which value of the `crash_analysis_command` argument to `run_it()` is used to provide the information needed to run.

- The second element (`env`)

  A *dict* value represents some built-in environment variables that are required.

- The third element (`parse_func`)

  A *function* which would be called. It's usually what you just wrote.

- The fourth element (`args`)

  A tuple represents some additional arguments needed when calling the parsing function.

  Note that `stderr` does not need to be included, as it will be passed automatically.

  These extra arguments are useful if your parser is working for different crash parsers at the same time and only needs to modify one or two values.

Some of the crash results can be parsed by different parsers, so it is especially important to choose an appropriate order. It is usually recommended to put the parser with more accurate results first. We will parse the crash from the first available parser (i.e. the one present in `crash_analysis_command`), and use the next one if it fails to parse.

### Specify the path in `crash_analysis_command`

You've got a new parser for the crash analyzer! Now you just need to specify the corresponding path in `crash_analysis_command` to use it!

<details>
<summary><h3>Advanced Usage: Parser Specifying and Backtracking</h3></summary>

In some special cases, your parser can't parse `stderr`, but you know which parser this should be handled by through some simple analysis. In this case, you can return `(("", <ID>, ""), )`, where `<ID>` is any object that can read the `_order_struct` object from `ORDER`, such as `1` or `-2`. If the `_order_struct` object cannot be read from `ORDER` using `<ID>`, it will be automatically selected (usually the next in line in order).

If `<ID>` is used, you can override the restriction on order imposed by `ORDER`. In this case, if you run a parser before the current parser, and that parser cannot parse this `stderr` in fact, a loop may occur. For this purpose, we provide the global constant `_MAX_TTL`. This constant specifies the maximum number of jumps. Note that parsing one by one by the order of `ORDER` is also treated as a jump, so please set an appropriate value for this constant so that it will not be terminated before `ORDER` has been fully executed. After terminating by hitting `_MAX_TTL`, the program will determine the vulnerability type and generate the appropriate hash based on the information currently available.

</details>

## How to adapt to other types of fuzzer

*Need to be done later...*

## Code Organization

```
 .
 ├── autofuzz
 │  ├── __init__.py                    <- Modules init
 │  ├── base_runner.py                 <- BaseRunner
 │  ├── config.py                      <- Global variables
 │  ├── cov_analysis.py                <- Code coverage analysis
 │  ├── crash_analysis.py              <- Crash analysis
 │  ├── entry.py                       <- Entry function
 │  ├── runner
 │  │  ├── afl.py                      <- AFL Runner controller
 │  │  └── libfuzzer.py                <- libFuzzer Runner controller
 │  ├── runner_pool.py                 <- Runner-Pool controller
 │  └── utils
 │     ├── get_from_queue.py           <- Get elements from Queue          Generator
 │     ├── loop_timer.py               <- Call back a function regularly   Class
 │     ├── placeholder_replacer.py     <- Deal with placeholder            Function
 │     ├── reader_and_writer.py        <- Model of Reader-Writer           Decorator, Context Manager
 │     ├── run_once.py                 <- Run one functions at a time      Decorator
 │     └── time_record.py              <- Time record                      Class, Context Manager, Decorator
 └── main.py                           <- Example main
```
